<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="author" content="Vittore F. Scolari,
				 (C) Institut Pasteur 2015">
    <title>Dade - our 3C DATA Devouring Protocol</title>
    <link rel="stylesheet" href="css/style.css">
    <link type="image/vnd.microsoft.icon"
	  href="images/favicon.ico"
	  rel="shortcut icon"></link>
  </head>

  <body>
    <header>
      <h1>Dade - our 3C DATA Devouring Protocol</h1>
      <!-- <h2 id="rickroll"><a href="http://rickrolled.fr/">NEW: Click here -->
      <!-- 	  for French version!!!</a></h2> -->
      <nav>
	<h2>Contents</h2>
        <ol>  
          <li><a href="#introduction">Introduction</a></li>  
          <li><a href="#tools">Tools</a></li>
	  <li><a href="#tutorial">Tutorial</a></li>	  
        </ol>  
      </nav>
    </header>
    
    <a name="introduction"></a>
    <h2>1. Introduction</h2>
    <p>
      Dade, to be pronounced as the English noun Dave with a "d"
      instead of a "v", is our toolbox to evolve "in silico" the 3C
      data from the 
      sequencing machine into quantitative observations. The software
      collect tools aimed at:
      <ul>
	<li>Identify restriction fragments on a reference genome</li>
	<li>Align 3C data on a reference genome</li>
	<li>Classify aligned read pairs</li>
	<li>Make statistics on the classification</li>
	<li>Make contact matrix</li>
	<li>Obtain the contact distributions</li>
	<li>...</li>
      </ul>
      If you need to do all the above things, than using this software
      will allow you to get your step done quick to better spend your
      time on further original analysis and data interpretation.
    </p>
    <h3>Phylosophy</h3>
    <p>
      The tools has been developed with some principles in mind, we
      hope that these ideas will help the user to obtain his objective
      in a pragmatic way. Primarly the tools are conceived to
      to do very simple things, and in order to obtain results the
      user needs to combine and use different tools together in an
      algorithmic fashion. Of course
      we know that some
      users would like to have a one-script-do-it-all, but this is not
      the case with Dade; tools which are conceived like that are often boxed
      monoliths, complicated and full of bugs, require a lot of configuration
      options and parameters, their code is obscure and modifications
      are impossibles; we follow the
      <a href="http://www.faqs.org/docs/artu/ch01s06.html">unix
      phylosophy</a> that consist in
      programming "short, sharp tools" which can be easily maintained
      and reused.

      Secondarily, we use always text files as file format (or gzipped
      text files) and avoid as much as possible to
      load the whole data into memory. While due to this principle we
      may lose some performances and the script may go slower than
      optimal, we gain due to the fact that our scripts scale well
      to huge amount of data/length of reference genomes
      (a part for a few exceptions, the memory consumption scales
      linearly) and due to the fact that the user can understand 
      the output of the scripts, view and filter it with standard
      tools and interpret it as he likes.
    </p>
    <h3>Installation</h3>
    <p>
      The software can be downloaded <a href="">here</a>, in order to
      extract the tar-ball type the following code in a Linux terminal:
      <code>tar -xzf tarball.tar.gz</code>
      the code, tested on Mac and Linux, depends on an installation
      of the <a href="https://www.perl.org/">Perl</a> programming
      language, which come standard in all Unix-like operating
      systems, and on an installation of
      <a href="http://bowtie-bio.sourceforge.net/bowtie2/">bowtie2</a>
      read alignment tool.
    </p><p>
      The code need a temporary directory on a fast harddrive with
      enough free space (1GB should suffice), the default temporary
      directory is set to "/data/temporary", in order to change the
      location, modify the configuration option in the file
      "share/mktemp_linux.pl". Also,
      you will need a lot of disk space to carry the analysis, pay
      attention to keep some hundreds gigabytes free in your data
      analysis directory.
    </p><p>
      If you need to display or print this document, and do it nicely
      as the author intended it to be, please use a recent version of
      the <a href="https://www.mozilla.org/fr/firefox/new/">Firefox</a>
      web browser.
    </p>
    <a name="tools"><h2>2. Tools</h2></a>
    <p>
      This section describes all the tools comprised in Dade. The
      following tools are currently completed:
      <ol>  
        <li><a href="#findrst">findrst.pl</a> tabulate the restriction
          fragments in a reference genome</li>
        <li><a href="#map">map.pl</a> Iterative mapping</li>
        <li><a href="#classify">classify.pl</a> Classification and
          selection of read pairs</li>
        <li><a href="#statistics">statistics.pl</a> Basic statistics
          of experiment</li>
	<li><a href="#rstmatrix">rstmatrix.pl</a> Make interaction
	  matrix between restriction fragments</li>
	<li><a href="#takediagblock">takediagblock.pl</a> Take a
	  square block on the diagonal of a matrix</li>
	<!-- <li><a href="#rstdistribution">rstdistrubution.pl</a></li> -->
	<li><a href="#rebin">rebin.pl</a> Rebin in genomic
	  cohordinates a matrix</li>
	<li><a href="#probdecon">probdecon.pl</a> Calculate
	  contact probability for each row of a matrix</li>
	<li><a href="#colmedia">colmedia.pl</a> Output a vector of
	  the columns mean and variance of a matrix</li>
	<li><a href="#colsum">colsum.pl</a> Output the sum of columns
	  of a matrix</li>
	<li><a href="#rowsum">rowsum.pl</a> Output the sum of rows of
	  a matrix</li>
	<li><a href="#transpose">transpose.pl</a> Transpose a
	  matrix</li>
	<!-- <li><a href="#distdistribution">distdistribution.pl</a></li> -->
	<li><a href="#todense">todense.pl</a> Export matrix to
	  standard dense matrix format</li>
	<li><a href="#tosparse">tosparse.pl</a> Export matrix to
	  standard sparse matrix format</li>
      </ol>  
    </p>
    <a name="findrst"><h3>2.1 findrst.pl</h3></a>
    <p>Identify restriction fragments on a reference genome
      <code>
	./findrst.pl name chr1.fa chr2.fa ... chrN.fa
      </code>
      Parameters: "name" is the name of the restriction enzyme used in
      the experiment, "chr1.fa chr2.fa ... chrN.fa" is a
      space-separated list of fasta sequences, one for each chromosome
      of the reference genome. Note: the order of the chrosomes
      matters and will be conserved in script results.
    </p><p>
      The list of restriction enzymes has been taken from
      the <a href="http://rebase.neb.com/rebase/rebase.html">REBASE</a>
      database, their name and their target sequences are stored
      in the file
      <code>
	share/bionetc.txt
      </code>
      The output consists in a table which describes each restriction
      fragment of every chromosome printed to standard output. The
      columns of the table correspond to the following information:
      <ul>
	<li>INDEX: unique global numeric value</li>
	<li>CHR: chromosome identifier string</li>
        <li>INDEXCHR: fragment numeric value local to
          chromosome</li>
	<li>START: Starting base-pair in the chromosome</li>
	<li>END: Ending base-pair in the chromosome</li> 
      </ul>
      In
      order to save the output to a file, use
      the <a href="https://www.gnu.org/software/bash/manual/html_node/Redirections.html">
	&gt; operator</a>. Example:
      <code>
	./findrst.pl DpnII chr1.fa chr2.fa chr3.fa &gt; DpnIIrst.txt
      </code>
      will output the table in the file DpnIIrst.txt .
    </p>
    <a name="map"><h3>2.2 map.pl</h3></a>
    <p>
      Map the sequencing data to the reference genome. The algorithm
      is a reimplementation of Leonid Mirny lab HICLib tool as
      described in their
      <a href="http://www.nature.com/nmeth/journal/v9/n10/full/nmeth.2148.html">
      Nature Methods paper</a>.
      <code>
	./map.pl leftsource rightsource readlength refgenome
	rsttable leftmap rightmap
      </code>
      Parameters: "leftsource" is the fastq file of the left read-end,
      "rightsource" is the fastq file of the right read-end, data may
      be gzipped, "readlenght" is the size in base pairs of the
      single sequenced read ends, "refgenome" is the reference genome
      basename of the
      <a href="http://bowtie-bio.sourceforge.net/bowtie2/">bowtie2</a>
      alignment index, the basename is the name of any of the index
      files up to but not including the final
      .1.bt2/.rev.1.bt2/etc. Index should have been built with the
      bowtie2-build tool from bowtie2 software collection. "rsttable" is the
      restriction fragment table built with ./findrst.pl tool,
      "leftmap" and "rightmap" are the output files with alignment
      informations respectively for the "leftsource" and "rightsource"
      input.
    </p>
    <p>
      The output files contain a table, which columns correspond to
      the following information:
      <ul>
	<li>INDEX: unique global numeric value</li>
	<li>NAME: name of aligned pair</li>
	<li>FLAG: <a href="http://samtools.github.io/hts-specs/SAMv1.pdf">
	    SAM format</a> bitwise flag</li>
	<li>CHR: chromosome identifier string (* if not aligned)</li>
	<li>POS: 1-based leftmost mapping position (* if not aligned)</li> 
	<li>MAPQ: Mapping quality</li>
	<li>RSIZE: Size of the trimmed read at alignment (iterative
	  mapping)</li>
	<li>RST: restriction fragment, identified its by INDEXCHR index in
	  "rsttable" input file (* if not aligned)</li>
      </ul>
      Append the extension .gz to output files in order to get them
      compressed.
    </p>
    <p>
      Attention: read mapping should be done only after demultiplexing
      and PCR duplicates removal.
    </p>
    <a name="classify"><h3>2.3 classify.pl</h3></a>
    <p>
      Classifies the read couples, categorize them by type. Useful for
      filtering the reads.
      <code>
      ./classify.pl leftmap rightmap classification
      </code>
      Parameters: the script takes the two file mapped
      by <a href="#map">./map.pl</a> as
      an input ("leftmap" and "rightmap") and outputs in the
      "classification" file (output is gzipped if .gz extension). The
      classification file contains for each line important
      informations about read couples, the output table is conceived for
      easy-parsing. The column in the output table correspond to the
      following informations:
      <ul>
	<li>INDEX: unique global numeric value
	(<a href="#map">./map.pl</a> output)</li> 
	<li>FLAG: Classification format bitwise flag (important: this is not
	  the SAM format flag, see details in the next section)</li>
	<li>LEFTCHR: Left read chromosome identifier
	(<a href="#map">./map.pl</a> output)</li> 
	<li>LEFTPOS: Left read alignment position
	(<a href="#map">./map.pl</a> output)</li> 
	<li>LEFTRST: Left read restriction fragment
	(<a href="#map">./map.pl</a> output)</li> 
	<li>RIGHTCHR: Right read chromosome identifier
	(<a href="#map">./map.pl</a> output)</li> 
	<li>RIGHTPOS: Right read alignment position
	(<a href="#map">./map.pl</a> output)</li> 
	<li>RIGHTRST: Right read restriction fragment
	  (<a href="#map">./map.pl</a> 
	  output)</li>
	<li>DIST: Chromosomal distance between left and right alignment</li>
	<li>RSTDIST: Chromosomal distance in restriction fragments</li>
      </ul>
      The FLAG field is a
      <a href="http://en.wikipedia.org/wiki/Bit_field">bitwise
      flag</a>, which means that it is a number that is ought to be
      interpreted in binary representation as a collection of boolean
      conditions. The boolean conditions and their reference bit are
      the following:
      <ul>
	<li>FL_LEFT_ALIGN => 2 : Left read aligned</li>
	<li>FL_RIGHT_ALIGN => 1 : Right read aligned</li>
	<li>FL_LEFT_INVERSE => 8 : Left read aligned being reverse
	  complemented</li>
	<li>FL_RIGHT_INVERSE => 4 : Right read aligned being reverse
	  complemented</li>
	<li>FL_INVERSE => 16 : Left read aligned at a position on
	  the chromosome greater than the mapping position of the
	  right read</li>
	<li>FL_INTRA_CHR => 32 : Left and right read aligned on the
	  same chromosome</li>
      </ul>
      The Perl code for interpreting and reading this flag
      is written in the file
      <code>
	share/flagdefinitions.pl
      </code>
      and can be trivially translated to other languages (e.g. R or
      Phyton); the code should be self-explanatory. Example: using
      "share/flagdefinitions.pl" it is possible to 
      check if a couple of aligned read ends are belonging to the same
      chromosome using boolean conditions:
      <code>
	(aligned($FLAG) && is(FL_INTRA_CHR, $FLAG))
      </code>
      thus, selecting all the read couples belonging to a certain
      class (i.e. aligned and same chromosome) and copying them in a
      file (named for example "selection"), in Perl, can be done with
      a one-liner (to be typed on the shell)
      <code>
	perl -ne 'BEGIN { require "share/flagdefinitions.pl"; }
	($INDEX,$FLAG,$LEFTCHR,$LEFTPOS,$LEFTRST,
	 $RIGHTCHR,$RIGHTPOS,$RIGHTRST,$DIST,$RSTDIST) =
	split("\t");<br />
	print if (aligned($FLAG) && is(FL_INTRA_CHR, $FLAG)) ;
	' classification &gt; selection
      </code>
      after the execution of the script.
    </p><p>
      The FLAG variable can be tested with any combinations of boolean
      conditions, the file "share/flagdefinitions.pl" contains, along
      with the definition of boolean conditions (FL_LEFT_ALIGN,
      FL_RIGHT_ALIGN, FL_LEFT_INVERSE, FL_RIGHT_INVERSE, FL_INVERSE,
      FL_INTRA_CHR)  the
      following pre-programmed tests and functions:
      <ul>
	<li><code class="inplace">is(cond, flag)</code> : check for bit
	  set, e.g. is(FL_INTRA_CHR, $FLAG)</li>
	<li><code class="inplace">isnot(cond, flag)</code> : check for
	  bit not set, 
	  e.g. isnot(FL_LEFT_ALIGN, $FLAG)</li> 
	<li><code class="inplace">aligned(flag)</code> : check if read
	is aligned, e.g. aligned($FLAG)</li> 
	<li><code class="inplace">bothunaligned(flag)</code> : check
	  if both ends didn't align, 
	  e.g. bothunaligned($FLAG)</li>
	<li><code class="inplace">single(flag)</code> : check if only
	  one read did align, 
	  e.g. single($FLAG)</li>
	<li><code class="inplace">plusmin(flag)</code> : check
	  alignment of type +/-, e.g. plusmin($FLAG); 
	  normally reads of this type at short distances may correspond to
	  uncut events. Useful check for filtering.
	<li><code class="inplace">minplus(flag)</code> : check
	  alignment of type -/+, e.g. minplus($FLAG); 
	  normally reads of this type at short distances may correspond to
	  uncut religated events. Useful check for filtering.
	<li><code class="inplace">plusplus(flag)</code> : check
	  alignment of type +/+, e.g. plusplus($FLAG). Useful check for
	  filtering.
	<li><code class="inplace">minmin(flag)</code> : check
	alignment of type -/-, e.g. minmin($FLAG). Useful check for filtering.
      </ul>
      also, the test on boolean conditions can be combined with a test
      on distance, for example the one-liner:
      <code>
	perl -ne 'BEGIN { require "share/flagdefinitions.pl"; }
	($INDEX,$FLAG,$LEFTCHR,$LEFTPOS,$LEFTRST,
	 $RIGHTCHR,$RIGHTPOS,$RIGHTRST,$DIST,$RSTDIST) =
	split("\t");<br />
	print if (plusmin($FLAG) && ($RSTDIST &lt; 5)) ;
	' classification &gt; selection
      </code>
      would select only aligned read ends of type +/- with distance in
      restriction fragments less than 5 and copy them in file selection.
    </p>
    <a name="statistics"><h3>2.4 statistics.pl</h3></a>
    <p>
      Make trivial statistics about 3C mapped reads
      <code>
	./statistics.pl classification
      </code>
      Parameters: the script takes the output file of
      <a href="#classify">./classify.pl</a> as input and output
      statistics to stdout.
      The program outputs number of reads and percentage of reads for
      the following classes:
      <ul>
	<li>Totality of reads ends in dataset</li>
	<li>Reads ends that aligned only on 1 side</li>
	<li>Reads ends that did not align on any side</li>
	<li>Reads ends that aligned on both sides</li>
	<li>Reads ends that aligned on the same chromosome</li>
	<li>Reads ends that aligned on the same chromosome and that
	  are of the +/- kind</li>
      </ul>
      Please contact <a href="email:vittore.scolari@pasteur.fr">me</a>
      if you think other observable classes are of interest
      and should be included in the official version of the script.
    </p><p>
      Reads of "+/-" kindness are for a big percentage self ligated
      contiguous fragments. Knowing this number is important since
      reads of this kind at small 
      distances (in restriction fragments) may be due noise. See 
      <a href="http://www.biomedcentral.com/1471-2164/13/436">this
      article</a>
      (<a href="http://www.biomedcentral.com/content/supplementary/1471-2164-13-436-s1.pdf">Figure
      S1</a>).
    </p><p>
      In order to save the output to a file, use
      the <a href="https://www.gnu.org/software/bash/manual/html_node/Redirections.html">
      &gt; operator</a>.
    </p>
    <a name="rstmatrix"><h3>2.5 rstmatrix.pl</h3></a>
    <p>
      Generate the matrix of interaction between the restriction
      fragments
      <code>
	./rstmatrix.pl classification rsttable matrix
      </code>
      Parameters: the script takes a file in the format of the output
      file "classification" of 
      <a href="#classify">./classify.pl</a> as the input parameter and
      "rsttable", the restriction fragment table generated using
      the <a href="findrst">./findrst.pl</a> script. Note: this is a
      low level script, if you run the script without previously
      selecting and filtering of the data the result will have nasty
      and unwanted biases; for this reason, before
      running this script you may want to select different
      subsets/selections of ./classify.pl output
      using "share/flagdefinitions.pl" functions, as described in
      the  <a href="#classify">./classify.pl</a> section of this
      document, and merge the matrices at a later stage of the
      analysis; check the <a href="#tutorial">tutorial</a> for
      detailed instruction on how to filter/normalize data using this
      and other tools.
    </p>
    <!--   the third -->
    <!--   argument of the script "nrstfilter" sets the filtering method: -->
    <!--   <ul> -->
    <!-- 	<li> -->
    <!-- 	  If it is a positive integer number, the filtering -->
    <!-- 	  drops all read ends couples of type  -->
    <!-- 	  "+/-" and "-/+" at distances lower than "nrstfilter" and count -->
    <!-- 	  two times the read ends of type "-/-" and "+/+" at those small -->
    <!-- 	  distances, in this case, the number "nrstfilter" should be -->
    <!-- 	  chosen only after the analysis of the restriction fragment -->
    <!-- 	  interactions histograms in function of distance by class -->
    <!-- 	  implemented in  -->
    <!-- 	  the  <a href="rstdistribution">./rstdistribution.pl</a> -->
    <!-- 	  script; -->
    <!-- 	</li><li> -->
    <!-- 	  If it is set to "0", no -->
    <!-- 	  filtering is applyed at all and all reads are taken into -->
    <!-- 	  account; -->
    <!-- 	</li><li> -->
    <!-- 	  If it is set to "-1", all read ends of type "+/-" and "-/+" -->
    <!-- 	  are dropped, and only read ends of type "-/-" and "+/+" are -->
    <!-- 	  taken into consideration. -->
    <!-- 	</li><li> -->
    <!-- 	  If it is set to "-2", the new local normalization method is used. -->
    <!-- 	</li> -->
    <!--   </ul> -->
    <!-- </p><p> -->
    <p>
      The script outputs an upper triangular matrix with number of rows and
      columns equal to the number of restriction fragments in the
      "rsttable" file.

      The row and column number of the matrix is
      ordered according to the INDEX field in 
      "rsttable" file so that each row/column corresponds to a
      specific restriction fragment; fields are tab ("\t")
      separated. The first row and the first column is reserved for
      the record name,
      for each record, the script sets the name to a string containing
      informations about the corresponding restriction
      fragment, separated with "~" characther in the following format:
      <code class="inplace">"INDEX~CHR~INDEXCHR~START~END"</code> (check
      <a href="#findrst">./findrst.pl</a> for details about the fields).
      In subsequent rows/columns, each cell contains the number of
      reads ends which align to
      the two restriction fragments corresponding to the row/column
      position. The matrix is 
      symmetric so only the upper part is filled and the lower part is
      omitted in the output file, so that the diagonal corresponds to
      the first row.
      If the matrix file name
      ends with ".gz", the output is automatically gzipped for
      compression.
      The tools <a href="#todense">./todense.pl</a>
      and <a href="#tosparse">./tosparse.pl</a> can be used to
      export the matrix to common formats (i.e. for loading in
      visualization tools).
    </p><p>
      After creation, matrices can be easily manipulated using Perl
      one-liners,
      
      for example, in order to filter out all the reads at
      distance (in restriction fragments) less then 5, the following
      code would work: 
      <code>
	perl -ne 'BEGIN {$header=&lt;&gt;; print $header;} chomp; ($title,
	@cells) = split("\t");
	<br />
	for $cell (0..$#cells) { $cells[$cell]=0 if $cell &lt; 5; };
	<br />
	print $title,"\t", join("\t",@cells), "\n";'
	&lt; matrix &gt; matrix.filtered 
      </code>
      to take the square of a matrix, the following:
      <code>
	perl -ne 'BEGIN {$header=&lt;&gt;; print $header;} chomp; ($title,
	@cells) = split("\t");
	<br />
	for $i (0..$#cells) { $cells[$i]=$cells[$i]**2 };
	<br />
	print $title,"\t", join("\t",@cells), "\n";'
	&lt; matrix &gt; matrix.squared
      </code>
      in order to make binary operations, instead, we need to load two
      matrices at the same time, this can be done by a combination of
      the paste command and the Perl splice function, for example, to
      add two matrices, we could use the following code:
      <code>
	paste matrix1 matrix2 | perl -ne 'BEGIN
	{$h=&lt;&gt;; $h=substr($h,length($h)/2); print $h;}
	<br />
	chomp;
	@cells1=split("\t");@cells2=splice(@cells1,scalar(@cells1)/2);
	$title1=shift(@cells1);$title2=shift(@cells2);
	<br />
	for $i (0..$#cells1) { $cells1[$i]=$cells1[$i]+$cells2[$i]; };
	<br />
	print $title2,"\t", join("\t",@cells1), "\n";'
	&gt; sum.matrices
      </code>
      note: binary operations makes sense only on matrices of the same
      dimensions.
    </p>
    <!-- <a name="rstdistribution"><h3>2.5 rstdistribution.pl</h3></a> -->
    <!-- <p> -->
    <!--   Plot the number of aligned reads in function of the genomic -->
    <!--   distance for the different classes ("+/+", "+/-", "-/+" and -->
    <!--   "-/-") of reads ends: -->
    <!--   <code> -->
    <!-- 	usage: ./rstdistribution.pl classification nrst -->
    <!--   </code> -->
    <!--   Parameters: the script takes the output file of -->
    <!--   <a href="#classify">./classify.pl</a> as the input parameter -->
    <!--   "classification", while "nrst" is the maximum distance between -->
    <!--   restriction fragment to consider in the graph; in doubt, put  -->
    <!--   "nrst" equal to 20. The output is 4 -->
    <!--   histograms in 4 different files: the name of the files will be -->
    <!--   the same as "classification" with an additional extension in the -->
    <!--   format of .TYPE.hist -->
    <!--   where TYPE can be pp ("+/+"), pm ("+/-"), mp ("-/+"), mm ("-/-") -->
    <!--   in function of the read ends classification. Histograms can be -->
    <!--   plotted with any plotting software (e.g. -->
    <!--   <a href="http://plasma-gate.weizmann.ac.il/Grace/">Grace</a>, -->
    <!--   <a href="http://www.r-project.org/">R</a> or -->
    <!--   <a href="http://rickrolled.fr/">Excel</a>). In order to properly -->
    <!--   proceed with the analysis, plot those plot together, and extract -->
    <!--   the filtering restriction distance as the distance at which the -->
    <!--   four curves converge together. -->
    <!-- </p> -->
    <a name="rebin"><h3>2.7 rebin.pl</h3></a>
    <p>
      Rebin the interaction matrix in chromosomal coordinates
      <code>
	./rebin.pl matrix rsttable binsize binmatrix
      </code>
      Parameters: the script takes four parameters, "matrix"
      is a upper diagonal matrix representing the interactions between
      restriction fragments (like the output of
      the <a href="#rstmatrix">./rstmatrix.pl</a> or
      <a href="#takediagblock">./takediagblock.pl</a> script); "rsttable"
      is the restriction fragment table of the
      reference genome generated using
      the <a href="#findrst">./findrst.pl</a> script; "binsize" sets
      the size in base-pairs of the chromosomal coordinate bin. Bins
      are computed taking into account the presence of multiple
      chromosomes and their border on the reference sequence.
      The output consists of a upper diagonal matrix containing the
      interactions between
      bins; The record names; in the output, are substituted with a
      field in the
      format <code class="inplace">CHR~POS</code> where "CHR" is the
      chromosome name of the bin and "POS" is the mean genomic
      cohordinate. The output is named as
      the parameter "binmatrix" and is 
      automatically gzipped if an ".gz"
      extension is present, it is instead printed to STDOUT if "binmatrix"
      is equal to "-".
    </p><p>
      Note: It is not possible to apply rebin.pl on an already binned
      matrix, always restart from the restriction fragment matrix
      while rebinning since it (still) contains the fragment informations.
    </p>
    <!-- <a name="distdistribution"><h3>2.8 distdistribution.pl</h3></a> -->
    <!-- <p> -->
    <!--   Make histograms of aligned read-ends in function of their -->
    <!--   genomic distance -->
    <!--   <code> -->
    <!-- 	./rstdistribution.pl rstmatrix rsttable centromtable stepsize (log|lin) -->
    <!--   </code> -->
    <!--   TO BE WRITTEN -->
    <!-- </p> -->
    <a name="colsum"><h3>2.7 colsum.pl</h3></a>
    <p>
      Output the sum of columns of a matrix
      <code>
	./colsum.pl [-a] matrix
      </code>
      Iterate through the matrix and make a sum of the columns, the
      optional "-a" parameter specify the way the sum is done. If
      "-a" is specified then the sum is done on the square matrix in the
      "algebric sense", otherwise the sum is done in "upper diagonal"
      sense. Exempli grata, for a restriction fragments interaction
      matrix the difference
      whould be that in the "algebraic" sense, for column number <i>n</i>,
      we are summing over all the
      interactions between the restriction fragment <i>n</i> and all the
      fragments positioned at lower genomic position <i>n' &lt; n</i>
      (useful for iterative normalization), while in the 
      "upper diagonal" sense, for column number <i>n</i>, we are
      summing over all the interactions
      at genomic distance in restriction fragments equal
      to <i>n</i> (useful for histogram making).
      </p><p>
      Output is printed to STDOUT, use
      the <a href="https://www.gnu.org/software/bash/manual/html_node/Redirections.html">
      &gt; operator</a> to redirect the output to a file.
      usefull for generating histograms of 
    </p>
    <a name="todense"><h3>2.13 todense.pl</h3></a>
    <p>
      Export the matrix from upper diagonal format into standard
      square dense matrix format
      <code>
	./todense.pl matrix densematrix
      </code>
      Parameters: "matrix" is the input matrix file in upper diagonal
      format, "densematrix" the output file. If output have ".gz"
      extension, it gets automatically compressed. If input or output
      have filename "-" then redirection will happen to respectively
      STDIN or STDOUT;
    </p>
    <a name="tosparse"><h3>2.14 tosparse.pl</h3></a>
    <p>
      Export the matrix from upper diagonal format into standard
      sparse matrix format
      <code>
	./tosparse.pl matrix sparsematrix
      </code>
      Parameters: "matrix" is the input matrix file in upper diagonal
      format, "sparsematrix" the output file. If output have ".gz"
      extension, it gets automatically compressed. If input or output
      have filename "-" then redirection will happen to respectively
      STDIN or STDOUT;
    </p>
    <a name="tutorial"></a>
    <h2>3. Tutorial</h2>
    <p>
      Producing 3C interaction
      matrices for a multi-chromosome organism is a technically
      challenging problem; I've written the scripts described in this
      tutorial and in the above sections of this document at the
      beginning of my postdoc in RSFG group at Institut Pasteur for
      the task of analysing this data. In this tutorial I will
      describe the steps that has been made to analyze in parallel two
      datasets.
    </p><p>
      The two dataset belong to an experiment which aims at describing
      the genome conformation douring the cell cycle of a Saccaromices
      Cerevisiae mutant with a syntetic 150kb long segment of the 4th
      chromosome which have equally spaced restriction
      fragments. Thus, the experiments aim at two objectives: the first
      is to describe and analyze the differences in chromosome
      conformation along the cell cycle, the second is to highlight
      the properties of the syntetic segment of chromosome. In turn
      this second objective should serve as a starting point to
      create new computational methods of 3C data normalization for
      biophysical quantification. In order to work on the task, we
      initially sequenced two dataset: "AsyncYeast3.0C" which is the
      sequencing of the asynchronous population and "G2mYeast3.0C"
      which is the sequencing of the population freezed in G2M phase
      using the Nocodazol drug at 15μg/ml.
    </p><p>
      The pipeline starts from two files for each dataset,
      corresponding to the two different read-ends:
      <code>
	Dataset AsyncYeast3.0C:<br />
	BC76_CTGT.dat.end1.pcrfree and<br />
	BC76_CTGT.dat.end2.pcrfree<br /><br />
	Dataset G2mYeast3.0C:<br />
	BC176_CGAT.dat.end1.pcrfree and<br />
	BC176_CGAT.dat.end2.pcrfree
      </code>
      we keep the couple of files in different directories.
      <h3>Preparing the reference genome</h3>
      The first important thing is to prepare the reference genome,
      three steps are necessary to accomplish this passage:
      <ol>
	<li>Collect the chromosomes fasta files</li>
	<li>Index the fasta files
	using <a href="http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml">
	bowtie2-build</a></li>
	<li>Create the restriction fragment sites file
	using <a href="#findrst">./findrst.pl</a></li>
      </ol>
      <b>1.</b> In our tutorial we downloaded the reference BY genome
      from the
      <a href="http://www.yeastgenome.org/">SGD database</a> in the
      following files:
      <code>
	ref/chr1.fa ref/chr2.fa ref/chr3.fa ref/chr4.fa ref/chr5.fa
	ref/chr6.fa ref/chr7.fa ref/chr8.fa ref/chr9.fa ref/chr10.fa
	ref/chr11.fa ref/chr12.fa ref/chr13.fa ref/chr14.fa
	ref/chr15.fa ref/chrM.fa
      </code>
      and replaced the chromosome 4 with the syntetic one:
      <code>
	AsyncYeast3.0C:<br />
	cp ChrIVentier_BYmeiosyn_T6.ape.fa ref/chr4.fa<br /><br />
	G2mYeast3.0C:<br />
	cp BYmeiosyn_T5.ape.fa ref/chr4.fa<br />
      </code>
      note: ape files have been previously converted to fasta files;
      check that they are complete.
    </p><p>
      <b>2.</b> Index the fasta file using bowtie2-build program,
      listing chromosomes in order:
      <code>
	cd ref;<br />
	bowtie2-build
	chr1.fa,chr2.fa,chr3.fa,chr4.fa,chr5.fa,chr6.fa,chr7.fa,chr8.fa,chr9.fa,chr10.fa,chr11.fa,chr12.fa,chr13.fa,chr14.fa,chr15.fa,chr16.fa,chrM.fa
	bwt2index;<br />
	cd ..;
      </code>
      so that the index will be contained in
      the <code class="inplace">ref/bwt2index</code> file.
    </p><p>
      <b>3.</b> Since we used the DpnII restriction enzime at the
      bench, we will use <a href="findrst">./findrst.pl</a> script to
      generate the a restriction fragment file
      named <code class="inplace">ref/DpnIIrst.txt</code> with the
      information about the cut sites using the following command:
      <code>
	cd ref;<br />
	../findrst.pl DpnII chr1.fa chr2.fa chr3.fa chr4a.fa chr4b.fa
	chr4c.fa chr5.fa chr6.fa chr7.fa chr8.fa chr9.fa chr10.fa
	chr11.fa chr12.fa chr13.fa chr14.fa chr15.fa chr16.fa chrM.fa
	&gt; DpnIIrst.txt;<br />
	cd ..;
      </code>
      <h3>Mapping and classify the reads</h3>
      The reads need to be mapped to the reference genome in order to
      continue the data analysis, this can be done with the iterative
      mapping script <a href="#map">./map.pl</a> typing the following
      commands:
      <code>
	AsyncYeast3.0C:<br />
	./map.pl BC76_CTGT.dat.end1.pcrfree BC76_CTGT.dat.end2.pcrfree
	ref/bwt2index ref/DpnIIrst.txt
	BC76_CTGT.dat.end1.pcrfree.map.gz
	BC76_CTGT.dat.end2.pcrfree.map.gz<br /><br />
	G2mYeast3.0C:<br />
	./map.pl BC176_CGAT.dat.end1.pcrfree BC176_CGAT.dat.end2.pcrfree
	ref/bwt2index ref/DpnIIrst.txt
	BC176_CGAT.dat.end1.pcrfree.map.gz
	BC176_CGAT.dat.end2.pcrfree.map.gz
      </code>
      (note: those commands can take multiple hours for completion) now
      the files with extension .map.gz contains the bowtie2
      alignment informations extracted from the SAM file. It is
      possible to list them with the
      command <code class="inplace">gzip -c filename.gz</code> .
      In order to
      classify the read ends by type and make a single file with the
      essential information about recorded genome contacts, we use the
      <a href="#classify">./classify.pl</a> script:
      <code>
	AsyncYeast3.0C:<br />
	./classify.pl
	BC76_CTGT.dat.end1.pcrfree.map.gz
	BC76_CTGT.dat.end2.pcrfree.map.gz BC76_CTGT.class;<br /><br />
	G2mYeast3.0C:<br />
	./classify.pl BC176_CGAT.dat.end1.pcrfree.map.gz
	BC176_CGAT.dat.end2.pcrfree.map.gz
	BC176_CGAT.class;
      </code>
      this way we obtain a file (BC76_CTGT.class.gz and
      BC176_CGAT.class.gz) with all the read pairs, their aligment
      position, their distances on the chromosome (if on the same
      chromosome), flagged by type.

      We can make a simple statistics on the dataset using the
      command:
      <code>
	AsyncYeast3.0C:<br />
	./statistics BC76_CTGT.class;<br /><br />
	G2mYeast3.0C:<br />
	./statisitcs BC176_CGAT.class;
      </code>

      In order to make a filter on the
      uncut events and the loop uncut events at short distances, we
      are interested to separate the interactions in term of plus (+) and
      min (-) classes. Those classes corresponds to the direction of
      alignment, a good description of their property can be found in
      this <a href="http://www.biomedcentral.com/1471-2164/13/436">
      article</a>, and we will soon discover how to easily produce the
      <a href="http://www.biomedcentral.com/content/supplementary/1471-2164-13-436-s1.pdf">Figure
      S1B</a> in this tutorial. We split the classified reads in 5
      files:
      <code>
	AsyncYeast3.0C:<br />
	BC76_CTGT.class.mm<br />
	BC76_CTGT.class.mp<br />
	BC76_CTGT.class.pm<br />
	BC76_CTGT.class.pp<br />
	BC76_CTGT.class.xc<br /><br />
	G2mYeast3.0C:<br />
	BC176_CGAT.class.mm<br />
	BC176_CGAT.class.mp<br />
	BC176_CGAT.class.pm<br />
	BC176_CGAT.class.pp<br />
	BC176_CGAT.class.xc<br /><br />
      </code>
      where the extensions "mm", "mp", "pm", "pp" and "xc" correspond
      respectively to classes minmin, minplus, plusmin, plusplus and
      inter-chromosome using the following commands: 
      <code>
	G2mYeast3.0C:<br />
	perl -ne 'BEGIN { require "share/flagdefinitions.pl"; }
	(undef,$FLAG)
	= split("\t"); print if (plusplus($FLAG));' BC176_CGAT.class &gt;
	BC176_CGAT.class.pp;<br /><br />
	perl -ne 'BEGIN { require "share/flagdefinitions.pl"; }
	(undef,$FLAG)
	= split("\t"); print if (plusmin($FLAG));' BC176_CGAT.class &gt;
	BC176_CGAT.class.pm;<br /><br />
	perl -ne 'BEGIN { require "share/flagdefinitions.pl"; }
	(undef,$FLAG)
	= split("\t"); print if (minplus($FLAG));' BC176_CGAT.class &gt;
	BC176_CGAT.class.mp;<br /><br />
	perl -ne 'BEGIN { require "share/flagdefinitions.pl"; }
	(undef,$FLAG)
	= split("\t"); print if (minmin($FLAG));' BC176_CGAT.class &gt;
	BC176_CGAT.class.mm;<br /><br />
	perl -ne 'BEGIN { require "share/flagdefinitions.pl"; }
	(undef,$FLAG)
	= split("\t"); print if (aligned($FLAG) && isnot(FL_INTRA_CHR,
	$FLAG)); ' BC176_CGAT.class &gt; 
	BC176_CGAT.class.xc;
      </code>
      we do the same for the AsyncYeast3.0C dataset changing the names
      accordingly.
      <h3>Creating the interaction matrices</h3>
      Once we have the classified reads, creating the interaction
      matrices is a question of running the following code in both 
      AsyncYeast3.0C and G2mYeast3.0C directories:
      <code>	
	for i in *.class.??; do ./rstmatrix.pl $i ref/DpnIIrst.txt
	$i.mat; done;
      </code>
      then just run
      <code class="inplace">ls *.mat</code>
      to list
      them. As you can see, now you have 5 matrices, but they are
      still not ready for visualization: we have 5 of them instead of
      1, we need to merge them, but not before some form of
      filtering! And then, after the filtering, the matrix would
      still probably be too sparse and in need of rebinning. We will
      introduce two kind of simple filtering in the next section,
      will rebin the matrix and visualize it in the following section and
      introduce an more insightful filtering algorithm in the
      section after.
      <h3>Basic filtering algorithms</h3>
      HiC protocol leads to dataset with an high number of
      uncut and uncut religated pair ends. This is evident from the
      result of the <a href="#statistics">./statistics.pl</a> script
      where you should have a good proportion of +/- kind of reads
      over the aligned. In fact both +/- and -/+ type of reads
      contains junk. In this section we will present two methods for
      filtering the junk.
    </p><p>
      <b>1.</b> The first way to eliminate this junk is to eliminate
      all +/- and
      -/+ kind of reads and produce an analysis based solely on -/-
      and +/+. This is easily accomplished by merging the latter two
      classes and ignoring the formers:
      <code>
	paste BC176_CGAT.class.pp.mat BC176_CGAT.class.mm.mat |
	perl -ne '
	<br />BEGIN {$h=&lt;&gt;; $h=substr($h,length($h)/2); print $h;}
	<br />chomp;
	@cells1=split("\t");@cells2=splice(@cells1,scalar(@cells1)/2);
	$title1=shift(@cells1);$title2=shift(@cells2);
	<br />
	for $i (0..$#cells1) { $cells1[$i]=$cells1[$i]+$cells2[$i]; };
	<br />
	print $title1,"\t", join("\t",@cells1), "\n";'
	&gt; BC176_CGAT.class.pp~mm.mat
      </code>
      (do the same for AsyncYeast3.0C) and, why not, add also the
      intra chromosomal interactions:
      <code>
	paste BC176_CGAT.class.pp~mm.mat BC176_CGAT.class.xc.mat |
	perl -ne '
	<br />BEGIN {$h=&lt;&gt;; $h=substr($h,length($h)/2); print $h;}
	<br />chomp;
	@cells1=split("\t");@cells2=splice(@cells1,scalar(@cells1)/2);
	$title1=shift(@cells1);$title2=shift(@cells2);
	<br />
	for $i (0..$#cells1) { $cells1[$i]=$cells1[$i]+$cells2[$i]; };
	<br />
	print $title1,"\t", join("\t",@cells1), "\n";'
	&gt; BC176_CGAT.class.pp~mm~xc.mat
      </code>      
      the result
      matrix <code class="inplace">BC176_CGAT.class.pp~mm~xc.mat</code>
      is clean filtered, but we lost almost half of valid read
      ends in the process.
    </p><p>
      <b>2.</b> The junk regards read ends which are at small distance
      in genomic cohordinates, so the next filtering algorithm
      would be to introduce a reasonable global cutoff for +/- and -/+
      reads at small distances.
      First of all let's find a way to get a reasonable cutoff
      size. We have interaction matrices for the different data types,
      let's now look at the number of interactions in function of
      restriction fragment distances in those classes, this can be
      accomplished by summing columns in the matrix. We can do this
      using the <a href="#colsum">./colsum.pl</a> script and with the
      following cycle:
      <code>
	for i in BC176_CGAT.class.[pm][pm].mat ;
	do ./colsum.pl $i &gt; $i.rstd;
	done;
      </code>
      if we make a plot of the "*.rstd" files (e.g. with tools like
      <a href="http://plasma-gate.weizmann.ac.il/Grace/">Grace</a>,
      <a href="http://www.r-project.org/">R</a>,
      <a href="http://rickrolled.fr/">Excel</a> or
      <a href="https://fr.libreoffice.org/">LibreOffice</a>) we
      obtain the following:
      <div><object data="images/rstd.pdf" type="application/pdf"
		   width="100%"
		   height="330px">
	  alt : <a href="images/test.pdf">test.pdf</a>
      </object></div>
      (note: note that we plotted only the first ~20 points and also,
      the use a logaritmic scale on the ordinate). You can see in
      this graph, that for small genomic distances (less then 5
      restriction fragments) the +/- curve stands out on top of the
      other curves. You can pick the cutoff like this, checking the
      point where the curves converge together, in our case 5
      restriction fragments.
    </p><p>
      In order to filter those restriction fragments from the +/- and
      the -/+ matrices first we merge the two matrices:
      <code>
	paste BC176_CGAT.class.pm.mat BC176_CGAT.class.mp.mat |
	perl -ne '
	<br >BEGIN {$h=&lt;&gt;; $h=substr($h,length($h)/2); print $h;}
	<br />chomp;
	@cells1=split("\t");@cells2=splice(@cells1,scalar(@cells1)/2);
	$title1=shift(@cells1);$title2=shift(@cells2);
	<br />
	for $i (0..$#cells1) { $cells1[$i]=$cells1[$i]+$cells2[$i]; };
	<br />
	print $title1,"\t", join("\t",@cells1), "\n";'
	&gt; BC176_CGAT.class.pm~mp.mat
      </code>
      then we use a one-liner to filter:
      <code>
	perl -ne 'BEGIN {$header=&lt;&gt;; print $header;} chomp; ($title,
	@cells) = split("\t");
	<br />
	for $i (0..$#cells) { $cells[$i]=0 if $i < 5; };
	<br />
	print $title,"\t", join("\t",@cells), "\n";'
	&lt; BC176_CGAT.class.pm~mp.mat &gt;
	BC176_CGAT.class.pm~mp~filt.mat
      </code>
      for normalization purposes, we duplicate the +/+ and -/-
      matrices (after merging) at genomic
      distances less than the cutoff:
      <code>
	perl -ne 'BEGIN {$header=&lt;&gt;; print $header;} chomp; ($title,
	@cells) = split("\t");
	<br />
	for $i (0..$#cells) { $cells[$i]=2*$cells[$i] if $i < 5; };
	<br />
	print $title,"\t", join("\t",@cells), "\n";'
	&lt; BC176_CGAT.class.pp~mm.mat &gt;
	BC176_CGAT.class.pp~mm~filt.mat
      </code>
      Then we merge the matrices together with the inter
      chromosomal "<code class="inplace">xc</code>" one to get a
      filtered matrix:
      <code>
	paste BC176_CGAT.class.pp~mm~filt.mat BC176_CGAT.class.pm~mp~filt.mat |
	perl -ne '
	<br />BEGIN {$h=&lt;&gt;; $h=substr($h,length($h)/2); print $h;}
	<br />chomp;
	@cells1=split("\t");@cells2=splice(@cells1,scalar(@cells1)/2);
	$title1=shift(@cells1);$title2=shift(@cells2);
	<br />
	for $i (0..$#cells1) { $cells1[$i]=$cells1[$i]+$cells2[$i]; };
	<br />
	print $title1,"\t", join("\t",@cells1), "\n";'
	&gt; BC176_CGAT.class.pp~mm~pm~mp~filt.mat<br /><br />
	paste BC176_CGAT.class.pp~mm~pm~mp~filt.mat BC176_CGAT.class.xc.mat |
	perl -ne '
	<br />BEGIN {$h=&lt;&gt;; $h=substr($h,length($h)/2); print $h;}
	<br />chomp;
	@cells1=split("\t");@cells2=splice(@cells1,scalar(@cells1)/2);
	$title1=shift(@cells1);$title2=shift(@cells2);
	<br />
	for $i (0..$#cells1) { $cells1[$i]=$cells1[$i]+$cells2[$i]; };
	<br />
	print $title1,"\t", join("\t",@cells1), "\n";'
	&gt; BC176_CGAT.class.pp~mm~pm~mp~xc~filt.mat
      </code>
      Obtaining a filtered and complete matrix in the
      file
      <code class="inplace">BC176_CGAT.class.pp~mm~pm~mp~xc~filt.mat</code>. The
      same method can be use on the AsyncYeast3.0C dataset.
      While this latter method of filtering is more sophisticated than
      the previous, we are 
      introducing a global cutoff which ignore local biases. This
      could lead to faults, in fact no only we are still trashing
      useful data, but also we may be introducing analysis artifacts
      which could produce tainted evidences in successive
      analysis steps. In a later section in this tutorial we will try
      to discuss with some data-at-hand this kind of problems and
      improve the filtering using more informations from the data.
    </p><p>
      By the way, for now, we could consider the matrices
      <code class="inplace">BC176_CGAT.class.pp~mm~xc.mat</code>
      and 
      <code class="inplace">BC176_CGAT.class.pp~mm~pm~mp~xc~filt.mat</code>
      clean and ready to be plotted, before doing that we should rebin
      the matrices.
      <h3>Rebinning and selecting part of the Matrix</h3>
      We have a matrix, we need to visualize it. In order to do that
      three steps are required to taking into consideration: (1)
      Rebinning the matrix, (2) Selecting a diagonal block, (3)
      Exporting the matrix to a common format. This three
      tasks can be done with
      the <a href="#rebin">./rebin.pl</a>,
      <a href="#takediagblock">./takediagblock.pl</a>,
      <a href="#takediagblock">./tosparse.pl</a> and
      <a href="#takediagblock">./todense.pl</a>
      tools which will be Tutorically described in this section. Let's
      do it together on the
      <code class="inplace">BC176_CGAT.class.pp~mm~pm~mp~xc~filt.mat</code>
      matrix!
    </p><p>
      <b>1.</b> In order to rebin the
      matrix, <a href="#rebin">./rebin.pl</a> comes as an handy tool:
      the script takes as input your matrix, the restriction fragment
      table and the binsize. It divides the reference genome in bins
      of equal size taking into account the chromosome boundaries and
      output an interaction matrix between the computed bins. If we
      want to make a matrix rebinned to 7 kilobases, it suffices that we
      type:
      <code>
	./rebin.pl BC176_CGAT.class.pp~mm~pm~mp~xc~filt.mat
	ref/DpnIIrst.txt 7000 BC176_CGAT.7k~rebinned
      </code>
      obtaining a rebinned matrix in
      <code class="inplace">BC176_CGAT.7k~rebinned</code>. Attention:
      1st: the script cannot be used on 
      a rebinned matrix
      (e.g. <code class="inplace">BC176_CGAT.7k~rebinned</code>),
      always start with the original! 2nd: The row names will not
      contain any more the restriction fragment information but the
      bin information, check it yourself by typing:
      <code class="inplace">less -S
      BC176_CGAT.class.pp~mm~pm~mp~xc~filt.mat;</code> and
      then <code class="inplace">less -S BC176_CGAT.7k~rebinned;</code>
      in order to see the difference.
    </p><p>
      <b>2.</b>
    </p><p>
      <b>3.</b>The tools which you will use to visualize your matrices
      (most probably Matlab, R or Python scripts) will not
      easily import matrices in the format used by Dade. Before
      opening them with those tools you can export them with
      the following commands:
      <code>
	./todense.pl BC176_CGAT.7k~rebinned BC176_CGAT.7k~rebinned.dat
      </code>
      to export to a dense matrix, or
      <code>
	./sparse.pl BC176_CGAT.7k~rebinned BC176_CGAT.7k~rebinned.dat
      </code>
      to export to a sparse matrix. Alternatively, you can load upper
      diagonal matrices directly in R by defining the following
      function: 
      <pre>
read.updiag &lt;- function (file) {
    a &lt;- read.table(file, header = TRUE, row.names=1,fill=1);
    cnames &lt;- colnames(a);
    a &lt;- t(apply(cbind(1:(dim(a)[1]), a)
               , 1
               , function(v) {
                   c(rep(0,v[1]-1), v[2:(length(v)-v[1]+1)])
               })
           );
    colnames(a) &lt;- cnames;
    a
}
      </pre>
      and subsequently using the function as 
      <code class="inplace">matrix <- read.updiag("matrixfilename");</code> .
      <h3>Experimentations on an advanced filtering algorithm</h3>
      <h3>Plotting the genomic distance contact probability</h3>
      <h3>Conclusions</h3>    
    </p>
    <footer>
      <p>Dade - programmed by Vittore F. Scolari,
	Spatial regulation of genomes
	© 2015 Institut Pasteur, Paris</p>
    </footer>
  </body>

</html>
